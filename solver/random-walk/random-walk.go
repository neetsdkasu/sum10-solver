package randomWalk

import (
	"context"
	"log"
	"sum10-solver/game"
	"sum10-solver/marker"
	"sum10-solver/problem"
	"sum10-solver/solver"
	"time"
)

type RandomWalk struct{}

var randomWalk = &RandomWalk{}

func init() {
	solver.Register(randomWalk)
}

func (*RandomWalk) Name() string {
	return "RandomWalk"
}

func (*RandomWalk) Description() string {
	return "find best one of solutions generated by random"
}

func (*RandomWalk) Search(startTime time.Time, runningSeconds int, problem *problem.Problem) []*marker.Marker {
	deadline := startTime.Add(time.Duration(int64(runningSeconds)) * time.Second)
	ctx, cancel := context.WithDeadline(context.Background(), deadline)
	defer cancel()
	var best = []*marker.Marker{}
	ch := search(ctx, problem)
	for {
		select {
		case <-ctx.Done():
			log.Println("end of search")
			return best
		case sol, ok := <-ch:
			if ok {
				log.Println("recieved")
				best = sol
			}
		}
	}
}

func search(ctx context.Context, problem *problem.Problem) <-chan []*marker.Marker {
	ch := make(chan []*marker.Marker, 100)

	game0 := game.New(problem)

	go func() {
		defer close(ch)

		_ = game0

		var hoge = []*marker.Marker{}
		for {
			select {
			case <-ctx.Done():
				log.Println("end and not send")
				return
			case ch <- hoge:
				log.Println("send")
			}
		}
	}()

	return ch
}
